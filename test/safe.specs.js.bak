const { expect } = require('chai');
const { deployContract, loadFixture } = require('ethereum-waffle');
const { ERC721, Safe, NFTKind, approve } = require('./helpers');

describe('SpectralizeSafe', () => {
  let ctx, tx, receipt, admin, locker, minter, owner, spectrum, others;

  const setup = async () => {
    ctx = {
      collection: await deployContract(admin, ERC721, ['Spectralize', 'SPC', 'ipfs://Qm.../']),
      ledger: await deployContract(admin, Ledger),
      // safe: await deployContract(admin, Safe),
    };

    await ctx.safe.initialize();

    await ctx.collection.grantRole(await ctx.collection.MINTER_ROLE(), minter.address);
    await ctx.safe.grantRole(await ctx.safe.LOCKER_ROLE(), locker.address);

    const _tx = await ctx.collection.mint(owner.address);
    const _receipt = await _tx.wait();
    ctx.tokenId = _receipt.events[0].args.tokenId.toString();
  };

  before(async () => {
    [admin, locker, minter, owner, spectrum, ...others] = await ethers.getSigners();
  });

  describe('# lock', () => {
    describe('» sender has LOCKER_ROLE', () => {
      describe('» NFT is not locked yet', () => {
        before(async () => {
          await loadFixture(setup);
          await approve(ctx, owner, ctx.safe.address);
          ctx.safe = ctx.safe.connect(locker);
          tx = await ctx.safe.lock(ctx.collection.address, ctx.tokenId, owner.address, spectrum.address);
          receipt = await tx.wait();
        });

        it('it transfers NFT', async () => {
          expect(await ctx.collection.ownerOf(ctx.tokenId)).to.equal(ctx.safe.address);
        });

        it('it locks NFT', async () => {
          const NFT = await ctx.safe.locked(ctx.collection.address, ctx.tokenId);

          expect(NFT.isLocked).to.equal(true);
          expect(NFT.kind).to.equal(NFTKind.ERC721);
          expect(NFT.owner).to.equal(owner.address);
          expect(NFT.spectrum).to.equal(spectrum.address);
        });

        it('it emits a Lock event', async () => {
          await expect(tx)
            .to.emit(ctx.safe, 'Lock')
            .withArgs(ctx.collection.address, ctx.tokenId, owner.address, spectrum.address);
        });
      });

      describe('» NFT is already locked', () => {
        before(async () => {
          await loadFixture(setup);
        });

        it('it reverts', async () => {
          await expect(ctx.safe.lock(ctx.collection.address, ctx.tokenId, owner.address, spectrum.address)).to.be.revertedWith('Safe: NFT already locked');
        });
      });
    });

    describe('» sender does not have LOCKER_ROLE', () => {
      before(async () => {
        await loadFixture(setup);
        ctx.safe = ctx.safe.connect(others[0]);
      });

      it('it reverts', async () => {
        await expect(ctx.safe.lock(ctx.collection.address, ctx.tokenId, owner.address, spectrum.address)).to.be.revertedWith('Safe: locker only operation');
      });
    });
  });

  describe('# unlock', () => {
    // TODO
  });
});
