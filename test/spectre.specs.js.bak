const { expect } = require('chai');
const { deployContract } = require('ethereum-waffle');
const { CloneFactory, PCT_BASE, Spectre } = require('./helpers');

describe('Spectre', () => {
  let tx,
    receipt,
    implementation,
    factory,
    spectre,
    wrapper,
    beneficiaries = [],
    user,
    others;

  const allocations = [ethers.BigNumber.from('200000000000000000'), ethers.BigNumber.from('100000000000000000'), ethers.BigNumber.from('50000000000000000')];
  const amount = ethers.BigNumber.from('1000000');
  const cap = ethers.BigNumber.from('1000000000000000000000000');

  const setup = async (opts = { initialize: true }) => {
    implementation = await deployContract(wrapper, Spectre);
    factory = await deployContract(wrapper, CloneFactory);

    tx = await factory.clone(implementation.address);
    receipt = await tx.wait();

    spectre = new ethers.Contract(receipt.events[0].args.proxy, Spectre.abi, wrapper);

    if (opts.initialize) {
      tx = await spectre.initialize(
        'Spectre Token',
        '$SPCTR',
        cap,
        [beneficiaries[0].address, beneficiaries[1].address, beneficiaries[2].address],
        [allocations[0], allocations[1], allocations[2]]
      );
      receipt = await tx.wait();
    }
  };

  before(async () => {
    [wrapper, beneficiaries[0], beneficiaries[1], beneficiaries[2], user, ...others] = await ethers.getSigners();
  });

  describe('» implementation contract', () => {
    before(async () => {
      await setup();
    });

    it('it reverts on initialization', async () => {
      await expect(
        implementation.initialize(
          'Spectre Token',
          '$SPCTR',
          cap,
          [beneficiaries[0].address, beneficiaries[1].address, beneficiaries[2].address],
          [allocations[0], allocations[1], allocations[2]]
        )
      ).to.be.revertedWith('Initializable: contract is already initialized');
    });
  });

  describe('» proxified contract', () => {
    describe('# initialize', () => {
      describe('» cap is valid', () => {
        describe('» and allocations arrays are valid', () => {
          describe('» and allocations beneficiaries are valid', () => {
            describe('» and allocations percentages are valid', () => {
              describe('» and allocations percentages do not overflow', () => {
                before(async () => {
                  await setup();
                });

                it('it registers allocations', async () => {
                  const sigma = allocations[0].add(allocations[1]).add(allocations[2]);
                  const factor = PCT_BASE.mul(sigma).div(PCT_BASE.sub(sigma));

                  const _allocations = await spectre.allocations();

                  expect(_allocations[0].beneficiary).to.equal(beneficiaries[0].address);
                  expect(_allocations[1].beneficiary).to.equal(beneficiaries[1].address);
                  expect(_allocations[2].beneficiary).to.equal(beneficiaries[2].address);

                  expect(_allocations[0].factor).to.equal(factor.mul(allocations[0]).div(sigma));
                  expect(_allocations[1].factor).to.equal(factor.mul(allocations[1]).div(sigma));
                  expect(_allocations[2].factor).to.equal(factor.mul(allocations[2]).div(sigma));
                });

                it('it emits Allocate events', async () => {
                  await expect(tx)
                    .to.emit(spectre, 'Allocate')
                    .withArgs(beneficiaries[0].address, allocations[0]);
                  await expect(tx)
                    .to.emit(spectre, 'Allocate')
                    .withArgs(beneficiaries[1].address, allocations[1]);
                  await expect(tx)
                    .to.emit(spectre, 'Allocate')
                    .withArgs(beneficiaries[2].address, allocations[2]);
                });

                it('it reverts on re-initialization', async () => {
                  await expect(
                    spectre.initialize(
                      'Spectre Token',
                      '$SPCTR',
                      cap,
                      [beneficiaries[0].address, beneficiaries[1].address, beneficiaries[2].address],
                      [allocations[0], allocations[1], allocations[2]]
                    )
                  ).to.be.revertedWith('Initializable: contract is already initialized');
                });
              });

              describe('» but allocations percentages overflow', () => {
                before(async () => {
                  await setup({ initialize: false });
                });

                it('it reverts', async () => {
                  await expect(
                    spectre.initialize(
                      'Spectre Token',
                      '$SPCTR',
                      cap,
                      [beneficiaries[0].address, beneficiaries[1].address, beneficiaries[2].address],
                      [ethers.BigNumber.from('500000000000000000'), ethers.BigNumber.from('250000000000000000'), ethers.BigNumber.from('250000000000000000')]
                    )
                  ).to.be.revertedWith('Spectre: allocations encompass the whole supply');
                });
              });
            });

            describe('» but allocations percentages are invalid', () => {
              before(async () => {
                await setup({ initialize: false });
              });

              it('it reverts', async () => {
                await expect(
                  spectre.initialize(
                    'Spectre Token',
                    '$SPCTR',
                    cap,
                    [beneficiaries[0].address, beneficiaries[1].address, beneficiaries[2].address],
                    [allocations[0], allocations[1], ethers.BigNumber.from('0')]
                  )
                ).to.be.revertedWith('Spectre: percentage must be comprised between 0% and 100%');
              });
            });
          });

          describe('» but allocations beneficiaries are invalid', () => {
            before(async () => {
              await setup({ initialize: false });
            });

            it('it reverts', async () => {
              await expect(
                spectre.initialize(
                  'Spectre Token',
                  '$SPCTR',
                  cap,
                  [ethers.constants.AddressZero, beneficiaries[1].address, beneficiaries[2].address],
                  [allocations[0], allocations[1], allocations[2]]
                )
              ).to.be.revertedWith('Spectre: invalid address');
            });
          });
        });

        describe('» but allocations arrays are invalid', () => {
          before(async () => {
            await setup({ initialize: false });
          });

          it('it reverts', async () => {
            await expect(
              spectre.initialize(
                'Spectre Token',
                '$SPCTR',
                cap,
                [beneficiaries[1].address, beneficiaries[2].address],
                [allocations[0], allocations[1], allocations[2]]
              )
            ).to.be.revertedWith('Spectre: allocations beneficiaries and percentages lengths mismatch');
          });
        });
      });

      describe('» cap is invalid', () => {
        before(async () => {
          await setup({ initialize: false });
        });

        it('it reverts', async () => {
          await expect(
            spectre.initialize(
              'Spectre Token',
              '$SPCTR',
              0,
              [beneficiaries[0].address, beneficiaries[1].address, beneficiaries[2].address],
              [allocations[0], allocations[1], allocations[2]]
            )
          ).to.be.revertedWith('ERC20Capped: cap is 0');
        });
      });
    });

    describe('# transferFromWrapper', () => {
      describe('» sender has WRAPPER_ROLE', () => {
        before(async () => {
          await setup();
          spectre = spectre.connect(wrapper);
          (await spectre.mint(user.address, amount)).wait();
          (await spectre.transferFromWrapper(user.address, others[0].address, amount)).wait();
        });

        it('it transfers tokens', async () => {
          expect(await spectre.balanceOf(user.address)).to.equal(ethers.BigNumber.from('0'));
          expect(await spectre.balanceOf(others[0].address)).to.equal(amount);
        });
      });

      describe('» sender does not have WRAPPER_ROLE', () => {
        before(async () => {
          await setup();
          spectre = spectre.connect(wrapper);
          (await spectre.mint(user.address, amount)).wait();
          spectre = spectre.connect(others[0]);
        });

        it('it reverts', async () => {
          await expect(spectre.transferFromWrapper(user.address, others[0].address, amount)).to.be.revertedWith('Spectre: protected operation');
        });
      });
    });

    describe('# mint', () => {
      describe('» sender has WRAPPER_ROLE', () => {
        before(async () => {
          await setup();
          spectre = spectre.connect(wrapper);
          (await spectre.mint(user.address, amount)).wait();
        });

        it('it mints beneficiary tokens', async () => {
          expect(await spectre.balanceOf(user.address)).to.equal(amount);
        });

        it('it mints allocations tokens', async () => {
          const supply = await spectre.totalSupply();

          expect(await spectre.balanceOf(beneficiaries[0].address)).to.equal(supply.mul(allocations[0]).div(PCT_BASE));
          expect(await spectre.balanceOf(beneficiaries[1].address)).to.equal(supply.mul(allocations[1]).div(PCT_BASE));
          expect(await spectre.balanceOf(beneficiaries[2].address)).to.equal(supply.mul(allocations[2]).div(PCT_BASE));
        });
      });

      describe('» sender does not have WRAPPER_ROLE', () => {
        before(async () => {
          await setup();
          spectre = spectre.connect(others[0]);
        });

        it('it reverts', async () => {
          await expect(spectre.mint(user.address, amount)).to.be.revertedWith('Spectre: protected operation');
        });
      });
    });
  });
});
